{"version":3,"file":"TerrainGeneration-498902be.js","sources":["../../src/pages/advanced/TerrainGeneration.jsx"],"sourcesContent":["import React, { Suspense, useRef, useMemo, useEffect } from 'react'\nimport { Canvas, useFrame } from '@react-three/fiber'\nimport { OrbitControls, Text } from '@react-three/drei'\nimport { useControls } from 'leva'\nimport styled from 'styled-components'\nimport { motion } from 'framer-motion'\nimport * as THREE from 'three'\n\nconst PageContainer = styled.div`\n  width: 100vw;\n  height: 100vh;\n  display: flex;\n  position: relative;\n  padding-top: 80px;\n`\n\nconst CanvasContainer = styled.div`\n  flex: 1;\n  height: calc(100vh - 80px);\n  position: relative;\n`\n\nconst InfoPanel = styled(motion.div)`\n  width: 350px;\n  background: rgba(26, 26, 26, 0.95);\n  backdrop-filter: blur(20px);\n  border-left: 1px solid rgba(255, 255, 255, 0.1);\n  padding: 2rem;\n  overflow-y: auto;\n  z-index: 100;\n`\n\nconst InfoTitle = styled.h2`\n  color: var(--accent-color);\n  font-size: 1.5rem;\n  margin-bottom: 1rem;\n  display: flex;\n  align-items: center;\n  gap: 0.5rem;\n`\n\nconst InfoDescription = styled.p`\n  color: var(--text-secondary);\n  line-height: 1.6;\n  margin-bottom: 1.5rem;\n`\n\nconst TechList = styled.ul`\n  color: var(--text-secondary);\n  margin-left: 1rem;\n  \n  li {\n    margin-bottom: 0.5rem;\n    \n    code {\n      background: rgba(0, 255, 255, 0.1);\n      color: var(--accent-color);\n      padding: 0.2rem 0.4rem;\n      border-radius: 4px;\n      font-size: 0.9rem;\n    }\n  }\n`\n\nconst CodeSection = styled.details`\n  margin-top: 2rem;\n  \n  summary {\n    color: var(--accent-color);\n    cursor: pointer;\n    font-weight: 600;\n    margin-bottom: 1rem;\n  }\n  \n  pre {\n    background: rgba(0, 0, 0, 0.5);\n    border: 1px solid rgba(255, 255, 255, 0.1);\n    border-radius: 8px;\n    padding: 1rem;\n    overflow-x: auto;\n    font-size: 0.8rem;\n    color: var(--text-secondary);\n  }\n`\n\n// Noise functions for terrain generation\nclass NoiseGenerator {\n  static random(x, y) {\n    const n = Math.sin(x * 12.9898 + y * 78.233) * 43758.5453\n    return (n - Math.floor(n))\n  }\n  \n  static interpolate(a, b, t) {\n    return a * (1 - t) + b * t\n  }\n  \n  static smoothNoise(x, y) {\n    const intX = Math.floor(x)\n    const intY = Math.floor(y)\n    const fracX = x - intX\n    const fracY = y - intY\n    \n    const a = this.random(intX, intY)\n    const b = this.random(intX + 1, intY)\n    const c = this.random(intX, intY + 1)\n    const d = this.random(intX + 1, intY + 1)\n    \n    const i1 = this.interpolate(a, b, fracX)\n    const i2 = this.interpolate(c, d, fracX)\n    \n    return this.interpolate(i1, i2, fracY)\n  }\n  \n  static perlinNoise(x, y, octaves = 4, persistence = 0.5) {\n    let total = 0\n    let frequency = 1\n    let amplitude = 1\n    let maxValue = 0\n    \n    for (let i = 0; i < octaves; i++) {\n      total += this.smoothNoise(x * frequency, y * frequency) * amplitude\n      maxValue += amplitude\n      amplitude *= persistence\n      frequency *= 2\n    }\n    \n    return total / maxValue\n  }\n  \n  static ridgedNoise(x, y, octaves = 4) {\n    let total = 0\n    let frequency = 1\n    let amplitude = 1\n    \n    for (let i = 0; i < octaves; i++) {\n      const n = this.smoothNoise(x * frequency, y * frequency)\n      const ridged = 1 - Math.abs(n * 2 - 1)\n      total += ridged * amplitude\n      amplitude *= 0.5\n      frequency *= 2\n    }\n    \n    return total\n  }\n}\n\n// Terrain component\nfunction Terrain({ \n  size = 100, \n  segments = 128, \n  heightScale = 10, \n  noiseType = 'perlin',\n  octaves = 4,\n  frequency = 0.05,\n  wireframe = false,\n  showColors = true\n}) {\n  const meshRef = useRef()\n  const geometryRef = useRef()\n  \n  const { geometry, heightData } = useMemo(() => {\n    const geo = new THREE.PlaneGeometry(size, size, segments, segments)\n    const positions = geo.attributes.position.array\n    const colors = new Float32Array(positions.length)\n    const heightData = new Float32Array((segments + 1) * (segments + 1))\n    \n    // Generate height data\n    for (let i = 0; i <= segments; i++) {\n      for (let j = 0; j <= segments; j++) {\n        const x = (i / segments - 0.5) * size\n        const z = (j / segments - 0.5) * size\n        \n        let height = 0\n        \n        switch (noiseType) {\n          case 'perlin':\n            height = NoiseGenerator.perlinNoise(x * frequency, z * frequency, octaves)\n            break\n          case 'ridged':\n            height = NoiseGenerator.ridgedNoise(x * frequency, z * frequency, octaves)\n            break\n          case 'simplex':\n            // Simplified simplex-like noise\n            height = NoiseGenerator.perlinNoise(x * frequency, z * frequency, octaves)\n            height = Math.pow(height, 1.5)\n            break\n          case 'volcanic':\n            // Create volcanic terrain\n            const distance = Math.sqrt(x * x + z * z)\n            const crater = Math.max(0, 1 - distance / (size * 0.3))\n            const rim = Math.exp(-Math.pow(distance - size * 0.2, 2) / (2 * Math.pow(size * 0.05, 2)))\n            height = crater * 0.3 + rim * 0.8 + NoiseGenerator.perlinNoise(x * frequency * 2, z * frequency * 2, 3) * 0.2\n            break\n          default:\n            height = NoiseGenerator.perlinNoise(x * frequency, z * frequency, octaves)\n        }\n        \n        height *= heightScale\n        heightData[i * (segments + 1) + j] = height\n        \n        // Set vertex height\n        const vertexIndex = i * (segments + 1) + j\n        positions[vertexIndex * 3 + 1] = height\n        \n        // Generate colors based on height\n        if (showColors) {\n          let color\n          const normalizedHeight = (height + heightScale) / (heightScale * 2)\n          \n          if (normalizedHeight < 0.2) {\n            // Water/Low areas - blue\n            color = new THREE.Color(0.1, 0.3, 0.8)\n          } else if (normalizedHeight < 0.4) {\n            // Beach/Sand - yellow\n            color = new THREE.Color(0.9, 0.8, 0.4)\n          } else if (normalizedHeight < 0.6) {\n            // Grass - green\n            color = new THREE.Color(0.2, 0.7, 0.2)\n          } else if (normalizedHeight < 0.8) {\n            // Rock - gray\n            color = new THREE.Color(0.5, 0.5, 0.5)\n          } else {\n            // Snow - white\n            color = new THREE.Color(0.9, 0.9, 0.9)\n          }\n          \n          colors[vertexIndex * 3] = color.r\n          colors[vertexIndex * 3 + 1] = color.g\n          colors[vertexIndex * 3 + 2] = color.b\n        } else {\n          colors[vertexIndex * 3] = 0.5\n          colors[vertexIndex * 3 + 1] = 0.5\n          colors[vertexIndex * 3 + 2] = 0.5\n        }\n      }\n    }\n    \n    geo.setAttribute('color', new THREE.BufferAttribute(colors, 3))\n    geo.computeVertexNormals()\n    \n    return { geometry: geo, heightData }\n  }, [size, segments, heightScale, noiseType, octaves, frequency, showColors])\n  \n  useEffect(() => {\n    if (geometryRef.current) {\n      geometryRef.current.copy(geometry)\n    }\n  }, [geometry])\n  \n  return (\n    <mesh ref={meshRef} rotation={[-Math.PI / 2, 0, 0]}>\n      <primitive object={geometry} ref={geometryRef} />\n      <meshStandardMaterial \n        vertexColors={showColors}\n        wireframe={wireframe}\n        side={THREE.DoubleSide}\n        color={showColors ? undefined : '#4a90e2'}\n      />\n    </mesh>\n  )\n}\n\n// Water plane for low areas\nfunction WaterPlane({ size = 100, level = -2 }) {\n  const meshRef = useRef()\n  \n  useFrame((state) => {\n    if (meshRef.current) {\n      meshRef.current.material.uniforms.time.value = state.clock.elapsedTime\n    }\n  })\n  \n  const waterMaterial = useMemo(() => {\n    return new THREE.ShaderMaterial({\n      uniforms: {\n        time: { value: 0 },\n        waterColor: { value: new THREE.Color(0.1, 0.3, 0.8) },\n        transparency: { value: 0.6 }\n      },\n      vertexShader: `\n        uniform float time;\n        varying vec2 vUv;\n        varying vec3 vPosition;\n        \n        void main() {\n          vUv = uv;\n          vec3 pos = position;\n          \n          // Small wave animation\n          pos.z += sin(pos.x * 0.1 + time) * 0.1;\n          pos.z += cos(pos.y * 0.1 + time * 1.3) * 0.05;\n          \n          vPosition = pos;\n          gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);\n        }\n      `,\n      fragmentShader: `\n        uniform float time;\n        uniform vec3 waterColor;\n        uniform float transparency;\n        \n        varying vec2 vUv;\n        varying vec3 vPosition;\n        \n        void main() {\n          vec2 uv = vUv;\n          \n          // Animated water texture\n          vec2 wave1 = vec2(sin(uv.x * 10.0 + time), cos(uv.y * 10.0 + time)) * 0.02;\n          vec2 wave2 = vec2(cos(uv.x * 15.0 - time * 1.5), sin(uv.y * 15.0 - time * 1.5)) * 0.01;\n          \n          vec2 distortedUv = uv + wave1 + wave2;\n          \n          vec3 color = waterColor;\n          \n          // Add some sparkle\n          float sparkle = sin(distortedUv.x * 50.0) * sin(distortedUv.y * 50.0);\n          sparkle = smoothstep(0.8, 1.0, sparkle);\n          color += sparkle * 0.2;\n          \n          gl_FragColor = vec4(color, transparency);\n        }\n      `,\n      transparent: true,\n      side: THREE.DoubleSide\n    })\n  }, [])\n  \n  return (\n    <mesh ref={meshRef} position={[0, level, 0]} rotation={[-Math.PI / 2, 0, 0]}>\n      <planeGeometry args={[size, size]} />\n      <primitive object={waterMaterial} />\n    </mesh>\n  )\n}\n\n// Clouds for atmosphere\nfunction Clouds() {\n  const cloudsRef = useRef()\n  \n  const cloudGeometry = useMemo(() => {\n    const geometry = new THREE.BufferGeometry()\n    const positions = []\n    const colors = []\n    \n    for (let i = 0; i < 1000; i++) {\n      const x = (Math.random() - 0.5) * 200\n      const y = Math.random() * 20 + 30\n      const z = (Math.random() - 0.5) * 200\n      \n      positions.push(x, y, z)\n      \n      const gray = 0.8 + Math.random() * 0.2\n      colors.push(gray, gray, gray)\n    }\n    \n    geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3))\n    geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3))\n    \n    return geometry\n  }, [])\n  \n  useFrame((state) => {\n    if (cloudsRef.current) {\n      cloudsRef.current.rotation.y = state.clock.elapsedTime * 0.01\n    }\n  })\n  \n  return (\n    <points ref={cloudsRef}>\n      <primitive object={cloudGeometry} />\n      <pointsMaterial\n        size={3}\n        sizeAttenuation\n        vertexColors\n        transparent\n        opacity={0.6}\n        alphaTest={0.001}\n      />\n    </points>\n  )\n}\n\nfunction Scene() {\n  const {\n    terrainSize,\n    terrainSegments,\n    heightScale,\n    noiseType,\n    octaves,\n    frequency,\n    wireframe,\n    showColors,\n    showWater,\n    showClouds,\n    waterLevel\n  } = useControls('地形控制', {\n    terrainSize: { value: 100, min: 50, max: 200, step: 10 },\n    terrainSegments: { value: 128, min: 32, max: 256, step: 32 },\n    heightScale: { value: 10, min: 1, max: 30, step: 1 },\n    noiseType: {\n      value: 'perlin',\n      options: {\n        'Perlin噪声': 'perlin',\n        '脊状噪声': 'ridged',\n        'Simplex噪声': 'simplex',\n        '火山地形': 'volcanic'\n      }\n    },\n    octaves: { value: 4, min: 1, max: 8, step: 1 },\n    frequency: { value: 0.05, min: 0.01, max: 0.2, step: 0.01 },\n    wireframe: { value: false },\n    showColors: { value: true },\n    showWater: { value: true },\n    showClouds: { value: true },\n    waterLevel: { value: -2, min: -10, max: 5, step: 0.5 }\n  })\n  \n  return (\n    <>\n      {/* Lighting */}\n      <ambientLight intensity={0.4} />\n      <directionalLight\n        position={[50, 50, 25]}\n        intensity={0.8}\n        castShadow\n        shadow-mapSize={[2048, 2048]}\n        shadow-camera-far={200}\n        shadow-camera-left={-100}\n        shadow-camera-right={100}\n        shadow-camera-top={100}\n        shadow-camera-bottom={-100}\n      />\n      \n      {/* Terrain */}\n      <Terrain\n        size={terrainSize}\n        segments={terrainSegments}\n        heightScale={heightScale}\n        noiseType={noiseType}\n        octaves={octaves}\n        frequency={frequency}\n        wireframe={wireframe}\n        showColors={showColors}\n      />\n      \n      {/* Water */}\n      {showWater && (\n        <WaterPlane size={terrainSize} level={waterLevel} />\n      )}\n      \n      {/* Clouds */}\n      {showClouds && <Clouds />}\n      \n      {/* Sky gradient */}\n      <mesh>\n        <sphereGeometry args={[300, 32, 32]} />\n        <meshBasicMaterial\n          color={new THREE.Color(0.5, 0.7, 1.0)}\n          side={THREE.BackSide}\n          transparent\n          opacity={0.3}\n        />\n      </mesh>\n      \n      {/* Title */}\n      <Text\n        position={[0, 40, 0]}\n        fontSize={3}\n        color=\"#00ffff\"\n        anchorX=\"center\"\n        anchorY=\"middle\"\n      >\n        程序化地形生成\n      </Text>\n      \n      {/* Info */}\n      <Text\n        position={[0, 35, 0]}\n        fontSize={1}\n        color=\"#ffffff\"\n        anchorX=\"center\"\n        anchorY=\"middle\"\n      >\n        噪声类型: {{\n          perlin: 'Perlin噪声',\n          ridged: '脊状噪声',\n          simplex: 'Simplex噪声',\n          volcanic: '火山地形'\n        }[noiseType]}\n      </Text>\n    </>\n  )\n}\n\nfunction TerrainGeneration() {\n  return (\n    <PageContainer>\n      <CanvasContainer>\n        <Canvas\n          camera={{ position: [50, 30, 50], fov: 75 }}\n          shadows\n          gl={{ antialias: true }}\n        >\n          <Suspense fallback={null}>\n            <Scene />\n            <OrbitControls\n              enableDamping\n              dampingFactor={0.05}\n              minDistance={10}\n              maxDistance={150}\n              maxPolarAngle={Math.PI / 2.2}\n            />\n          </Suspense>\n        </Canvas>\n      </CanvasContainer>\n      \n      <InfoPanel\n        initial={{ x: 350 }}\n        animate={{ x: 0 }}\n        transition={{ duration: 0.5 }}\n      >\n        <InfoTitle>\n          🏔️ 地形生成\n        </InfoTitle>\n        \n        <InfoDescription>\n          程序化地形生成是游戏开发和可视化中的重要技术，通过数学算法和噪声函数可以创建逼真的自然地形，无需手工建模。\n        </InfoDescription>\n        \n        <h3 style={{ color: 'var(--accent-color)', marginBottom: '1rem' }}>噪声算法</h3>\n        <TechList>\n          <li><code>Perlin噪声</code> - 经典噪声，平滑自然的地形</li>\n          <li><code>Simplex噪声</code> - 改进版本，更少的方向性偏差</li>\n          <li><code>脊状噪声</code> - 创建山脊和峡谷效果</li>\n          <li><code>分形噪声</code> - 多层次细节，增加复杂度</li>\n        </TechList>\n        \n        <h3 style={{ color: 'var(--accent-color)', marginBottom: '1rem', marginTop: '2rem' }}>地形特征</h3>\n        <TechList>\n          <li><code>高度图</code> - 基于灰度值的高度信息</li>\n          <li><code>法线计算</code> - 自动计算表面法线</li>\n          <li><code>纹理混合</code> - 基于高度的多纹理混合</li>\n          <li><code>LOD系统</code> - 距离相关的细节层次</li>\n        </TechList>\n        \n        <h3 style={{ color: 'var(--accent-color)', marginBottom: '1rem', marginTop: '2rem' }}>生成参数</h3>\n        <TechList>\n          <li><code>Octaves</code> - 噪声层数，影响细节丰富度</li>\n          <li><code>Frequency</code> - 频率，控制地形特征大小</li>\n          <li><code>Amplitude</code> - 振幅，控制高度变化范围</li>\n          <li><code>Persistence</code> - 持续性，控制细节衰减</li>\n        </TechList>\n        \n        <h3 style={{ color: 'var(--accent-color)', marginBottom: '1rem', marginTop: '2rem' }}>视觉增强</h3>\n        <TechList>\n          <li><code>顶点着色</code> - 基于高度的颜色变化</li>\n          <li><code>水面模拟</code> - 动态水波效果</li>\n          <li><code>大气效果</code> - 云层和天空盒</li>\n          <li><code>阴影映射</code> - 增强立体感</li>\n        </TechList>\n        \n        <h3 style={{ color: 'var(--accent-color)', marginBottom: '1rem', marginTop: '2rem' }}>优化策略</h3>\n        <InfoDescription>\n          • 使用LOD减少远距离多边形<br/>\n          • 视锥体剔除不可见区域<br/>\n          • 分块加载大型地形<br/>\n          • GPU计算加速噪声生成<br/>\n          • 缓存生成的地形数据\n        </InfoDescription>\n        \n        <CodeSection>\n          <summary>🔍 查看核心代码</summary>\n          <pre>{`// Perlin噪声实现\nclass NoiseGenerator {\n  static perlinNoise(x, y, octaves = 4, persistence = 0.5) {\n    let total = 0\n    let frequency = 1\n    let amplitude = 1\n    let maxValue = 0\n    \n    for (let i = 0; i < octaves; i++) {\n      total += this.smoothNoise(x * frequency, y * frequency) * amplitude\n      maxValue += amplitude\n      amplitude *= persistence\n      frequency *= 2\n    }\n    \n    return total / maxValue\n  }\n  \n  static smoothNoise(x, y) {\n    const intX = Math.floor(x)\n    const intY = Math.floor(y)\n    const fracX = x - intX\n    const fracY = y - intY\n    \n    const a = this.random(intX, intY)\n    const b = this.random(intX + 1, intY)\n    const c = this.random(intX, intY + 1)\n    const d = this.random(intX + 1, intY + 1)\n    \n    const i1 = this.interpolate(a, b, fracX)\n    const i2 = this.interpolate(c, d, fracX)\n    \n    return this.interpolate(i1, i2, fracY)\n  }\n}\n\n// 地形生成\nfunction generateTerrain(size, segments, heightScale) {\n  const geometry = new THREE.PlaneGeometry(size, size, segments, segments)\n  const positions = geometry.attributes.position.array\n  const colors = new Float32Array(positions.length)\n  \n  for (let i = 0; i <= segments; i++) {\n    for (let j = 0; j <= segments; j++) {\n      const x = (i / segments - 0.5) * size\n      const z = (j / segments - 0.5) * size\n      \n      // 生成高度\n      const height = NoiseGenerator.perlinNoise(\n        x * 0.05, z * 0.05, 4, 0.5\n      ) * heightScale\n      \n      const vertexIndex = i * (segments + 1) + j\n      positions[vertexIndex * 3 + 1] = height\n      \n      // 基于高度的颜色\n      const normalizedHeight = (height + heightScale) / (heightScale * 2)\n      let color\n      \n      if (normalizedHeight < 0.2) {\n        color = new THREE.Color(0.1, 0.3, 0.8) // 水\n      } else if (normalizedHeight < 0.4) {\n        color = new THREE.Color(0.9, 0.8, 0.4) // 沙滩\n      } else if (normalizedHeight < 0.6) {\n        color = new THREE.Color(0.2, 0.7, 0.2) // 草地\n      } else if (normalizedHeight < 0.8) {\n        color = new THREE.Color(0.5, 0.5, 0.5) // 岩石\n      } else {\n        color = new THREE.Color(0.9, 0.9, 0.9) // 雪\n      }\n      \n      colors[vertexIndex * 3] = color.r\n      colors[vertexIndex * 3 + 1] = color.g\n      colors[vertexIndex * 3 + 2] = color.b\n    }\n  }\n  \n  geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3))\n  geometry.computeVertexNormals()\n  \n  return geometry\n}\n\n// 水面着色器\nconst waterShader = {\n  uniforms: {\n    time: { value: 0 },\n    waterColor: { value: new THREE.Color(0.1, 0.3, 0.8) }\n  },\n  vertexShader: \\`\n    uniform float time;\n    varying vec2 vUv;\n    \n    void main() {\n      vUv = uv;\n      vec3 pos = position;\n      \n      // 水波动画\n      pos.z += sin(pos.x * 0.1 + time) * 0.1;\n      pos.z += cos(pos.y * 0.1 + time * 1.3) * 0.05;\n      \n      gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);\n    }\n  \\`,\n  fragmentShader: \\`\n    uniform float time;\n    uniform vec3 waterColor;\n    varying vec2 vUv;\n    \n    void main() {\n      vec2 wave = vec2(\n        sin(vUv.x * 10.0 + time),\n        cos(vUv.y * 10.0 + time)\n      ) * 0.02;\n      \n      vec3 color = waterColor;\n      \n      // 添加波光\n      float sparkle = sin((vUv.x + wave.x) * 50.0) * \n                     sin((vUv.y + wave.y) * 50.0);\n      sparkle = smoothstep(0.8, 1.0, sparkle);\n      color += sparkle * 0.2;\n      \n      gl_FragColor = vec4(color, 0.6);\n    }\n  \\`\n}`}</pre>\n        </CodeSection>\n      </InfoPanel>\n    </PageContainer>\n  )\n}\n\nexport default TerrainGeneration"],"names":["PageContainer","styled","CanvasContainer","InfoPanel","motion","InfoTitle","InfoDescription","TechList","CodeSection","NoiseGenerator","x","y","n","a","b","t","intX","intY","fracX","fracY","c","d","i1","i2","octaves","persistence","total","frequency","amplitude","maxValue","i","ridged","Terrain","size","segments","heightScale","noiseType","wireframe","showColors","meshRef","useRef","geometryRef","geometry","heightData","useMemo","geo","THREE.PlaneGeometry","positions","colors","j","z","height","distance","crater","rim","vertexIndex","color","normalizedHeight","THREE.Color","THREE.BufferAttribute","useEffect","jsxs","jsx","THREE.DoubleSide","WaterPlane","level","useFrame","state","waterMaterial","THREE.ShaderMaterial","Clouds","cloudsRef","cloudGeometry","THREE.BufferGeometry","gray","THREE.Float32BufferAttribute","Scene","terrainSize","terrainSegments","showWater","showClouds","waterLevel","useControls","Fragment","THREE.BackSide","Text","TerrainGeneration","Canvas","Suspense","OrbitControls"],"mappings":"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"}